<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://eliasdaler.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=me href=https://mastodon.gamedev.place/@eliasdaler><link rel=alternate type=application/rss+xml href=https://eliasdaler.github.io/feed.xml title="Elias Daler's blog"><title>How to implement action sequences and cutscenes</title></head><body><header id=banner><h2><a href=https://eliasdaler.github.io>Elias Daler's blog</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>How to implement action sequences and cutscenes</h1><div>Publication date: <time>October 3, 2018</time></div><div></div></header><h2 id=introduction>Introduction</h2><p><a href=https://habr.com/post/427135/>Russian translation</a></p><p>This post will show ways of implementing actions sequences and cutscenes in video games. The code is written in Lua, but the patterns can be implemented with other languages (except the coroutine approach, because not all languages have coroutines).</p><p>Action sequences frequently appear in games. In cutscenes, for example: a character approaches an enemy, says something, the enemy responds and so on. But action sequences often appear in gameplay as well. Take a look at this gif for example:</p><figure><img src=going-into-bar.gif></figure><p>We see the following sequence of actions:</p><ol><li>The door is opened</li><li>The player goes inside the house</li><li>The door closes</li><li>The screen fades out</li><li>Level changes</li><li>The screen fades in</li><li>The player enters the building</li></ol><p>Action sequences can be used when scripting NPC behavior and boss fights. For example, you can have a boss throw something at you, then laugh, then shook its fist in your direction. But implementing such things is not an easy task&mldr;</p><div><h2>Table Of Contents</h2><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#the-problem>The problem</a></li><li><a href=#booleans-enums-state-machines>Booleans, enums, state machines</a></li><li><a href=#action-lists>Action lists</a></li><li><a href=#coroutines>Coroutines</a><ul><li><a href=#coroutines-basics>Coroutines basics</a></li><li><a href=#implementing-cutscenes-with-coroutines>Implementing cutscenes with coroutines</a></li><li><a href=#advanced-usage>Advanced usage</a></li><li><a href=#pros-and-cons-of-coroutines>Pros and cons of coroutines</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div><h2 id=the-problem>The problem</h2><p>Unfortunately, standard game loop doesn&rsquo;t make it easy for us. Suppose we have this game loop:</p><figure><img src=game-loop.png></figure><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>while</span> game:isRunning() <span style=font-weight:700>do</span>
</span></span><span style=display:flex><span>  processInput()
</span></span><span style=display:flex><span>  dt <span style=font-weight:700>=</span> clock.delta()
</span></span><span style=display:flex><span>  update(dt)
</span></span><span style=display:flex><span>  render()
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>Now, suppose you want to implement the following cutscene: a player goes to an NPC, and the NPC says &ldquo;You did it!&rdquo;, and then after short delay it says &ldquo;Thank you!&rdquo;. In ideal world, we&rsquo;d want to write it like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>player:goTo(npc)
</span></span><span style=display:flex><span>npc:say(<span style=color:#b84>&#34;You did it!&#34;</span>)
</span></span><span style=display:flex><span>delay(<span style=color:#099>0.5</span>)
</span></span><span style=display:flex><span>npc:say(<span style=color:#b84>&#34;Thank you&#34;</span>)
</span></span></code></pre></div><p>And that&rsquo;s when we hit the first roadblock. All these actions take some time to complete. Some might even require user input - for example, to close a dialogue window before the cutscene can proceed further. As for <code>delay</code>, you can&rsquo;t just call <code>sleep</code> function there, because the game will freeze. It won&rsquo;t be updated and will be stuck in one iteration of the game loop.</p><p>Let&rsquo;s take a look at some of the possible solutions to the problem.</p><h2 id=booleans-enums-state-machines>Booleans, enums, state machines</h2><p>The most obvious and brute-force way to implement action sequence is to store the information about its state in booleans, strings or enums. The code will look something like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>update</span>(dt)
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> cutsceneState <span style=font-weight:700>==</span> <span style=color:#b84>&#39;playerGoingToNpc&#39;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>    player:continueGoingTo(npc)
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> player:closeTo(npc) <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>      cutsceneState <span style=font-weight:700>=</span> <span style=color:#b84>&#39;npcSayingYouDidIt&#39;</span>
</span></span><span style=display:flex><span>      dialogueWindow:show(<span style=color:#b84>&#34;You did it!&#34;</span>)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>elseif</span> cutsceneState <span style=font-weight:700>==</span> <span style=color:#b84>&#39;npcSayingYouDidIt&#39;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> dialogueWindow:wasClosed() <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>      cutsceneState <span style=font-weight:700>=</span> <span style=color:#b84>&#39;delay&#39;</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>elseif</span> ...
</span></span><span style=display:flex><span>    ... <span style=color:#998;font-style:italic>-- so on...</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>This approach can easily lead to spaghetti code and long if-else chains, so I&rsquo;d recommend to avoid it.</p><h2 id=action-lists>Action lists</h2><p>Action lists are similar to state machines. Action list is a list of actions which are executed sequentially. You can think of an action as a state in state machine. We update the current action in every iteration of game loop. If we see that the action has finished, we move on to the next one.</p><p>In our example, we can implement the following actions: <code>GoToAction</code>, <code>DialogueAction</code> and <code>DelayAction</code>. Let&rsquo;s look at the implementation of <code>DelayAction</code>.</p><blockquote class=hint-info>I&rsquo;m using <a href=https://github.com/kikito/middleclass>middleclass</a> library for OOP in Lua</blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#998;font-style:italic>-- constructor</span>
</span></span><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>DelayAction</span>:<span style=color:#900;font-weight:700>initialize</span>(params)
</span></span><span style=display:flex><span>  self.delay <span style=font-weight:700>=</span> params.delay
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  self.currentTime <span style=font-weight:700>=</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>  self.isFinished <span style=font-weight:700>=</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>DelayAction</span>:<span style=color:#900;font-weight:700>update</span>(dt)
</span></span><span style=display:flex><span>  self.currentTime <span style=font-weight:700>=</span> self.currentTime <span style=font-weight:700>+</span> dt
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> self.currentTime <span style=font-weight:700>&gt;</span> self.delay <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>    self.isFinished <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p><code>ActionList</code>&rsquo;s <code>update</code> function looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>ActionList</span>:<span style=color:#900;font-weight:700>update</span>(dt)
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> self.isFinished <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>    self.currentAction:update(dt)
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> self.currentAction.isFinished <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>      self:goToNextAction()
</span></span><span style=display:flex><span>      <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> self.currentAction <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>        self.isFinished <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>      <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>And finally, our cutscene looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>makeCutsceneActionList</span>(player, npc)
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> ActionList:new {
</span></span><span style=display:flex><span>    GoToAction:new {
</span></span><span style=display:flex><span>      entity <span style=font-weight:700>=</span> player,
</span></span><span style=display:flex><span>      target <span style=font-weight:700>=</span> npc
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    SayAction:new {
</span></span><span style=display:flex><span>      entity <span style=font-weight:700>=</span> npc,
</span></span><span style=display:flex><span>      text <span style=font-weight:700>=</span> <span style=color:#b84>&#34;You did it!&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    DelayAction:new {
</span></span><span style=display:flex><span>      delay <span style=font-weight:700>=</span> <span style=color:#099>0.5</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    SayAction:new {
</span></span><span style=display:flex><span>      entity <span style=font-weight:700>=</span> npc,
</span></span><span style=display:flex><span>      text <span style=font-weight:700>=</span> <span style=color:#b84>&#34;Thank you&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- ... and then somewhere in update:</span>
</span></span><span style=display:flex><span>actionList:update(dt)
</span></span></code></pre></div><blockquote class=hint-info>In Lua <code>someFunction({ ... })</code> can be written as <code>someFunction{...}</code>, that&rsquo;s why instead of writing <code>DelayAction:new({delay = 0.5})</code> we can write <code>DelayAction:new{ delay = 0.5 }</code></blockquote><p>This looks much better. We now have a clear sequence of actions. If we want to insert new action in a cutscene, we can easily do so. And we can reuse common actions in lots of action sequences.</p><p>See <a href="https://www.youtube.com/watch?v=o6CaB-hmqoE">this talk</a> by Sean Middleditch for more details and trickier usages of action lists:</p><p>Action lists are very useful. I&rsquo;ve used them for several years before discovering coroutine approach and was very happy. But then I wanted to make more complex cutscenes like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> <span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>cutscene</span>(player, npc)
</span></span><span style=display:flex><span>  player:goTo(npc)
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> player:hasCompleted(quest) <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>    npc:say(<span style=color:#b84>&#34;You did it!&#34;</span>)
</span></span><span style=display:flex><span>    delay(<span style=color:#099>0.5</span>)
</span></span><span style=display:flex><span>    npc:say(<span style=color:#b84>&#34;Thank you&#34;</span>)
</span></span><span style=display:flex><span>  <span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>    npc:say(<span style=color:#b84>&#34;Please help me&#34;</span>)
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>With action lists you&rsquo;ll need non-linear lists to make this happen. This can be accomplished by actions having tags. Then, you&rsquo;ll be able to jump to a tagged action instead of the next one. This works, but it is not as readable as the function above.</p><p>We can make this code real with coroutines.</p><h2 id=coroutines>Coroutines</h2><h3 id=coroutines-basics>Coroutines basics</h3><p>Coroutine is a function which can be &ldquo;paused&rdquo; and &ldquo;resumed&rdquo;. It is executed in <strong>the same thread</strong> as your main program. No new threads are created for it.</p><p>Coroutines can be paused with <code>coroutine.yield</code> and resumed with <code>coroutine.resume</code>. Here&rsquo;s a simple example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> <span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>f</span>()
</span></span><span style=display:flex><span>  print(<span style=color:#b84>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>  coroutine.yield()
</span></span><span style=display:flex><span>  print(<span style=color:#b84>&#34;world!&#34;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>local</span> c <span style=font-weight:700>=</span> coroutine.create(f)
</span></span><span style=display:flex><span>coroutine.resume(c)
</span></span><span style=display:flex><span>print(<span style=color:#b84>&#34;uhh...&#34;</span>)
</span></span><span style=display:flex><span>coroutine.resume(c)
</span></span></code></pre></div><p>The output is:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>hello
</span></span><span style=display:flex><span>uhh...
</span></span><span style=display:flex><span>world
</span></span></code></pre></div><p>First we create a coroutine with <code>coroutine.create</code>. Coroutine doesn&rsquo;t start to execute after it&rsquo;s created. It needs to be launched by <code>coroutine.resume</code>. <code>f</code> function is called then, it prints &ldquo;hello&rdquo; and then pauses itself by yielding. You can think of it as a form of <code>return</code>, but we can still resume the function afterwards by calling <code>coroutine.resume</code> if coroutine hasn&rsquo;t finished its function.</p><p>If you pass arguments when calling <code>coroutine.yield</code>, they&rsquo;re returned by <code>coroutine.resume</code> in the &ldquo;main thread&rdquo;. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> <span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>f</span>()
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    coroutine.yield(<span style=color:#099>42</span>, <span style=color:#b84>&#34;some text&#34;</span>)
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ok, num, text <span style=font-weight:700>=</span> coroutine.resume(c)
</span></span><span style=display:flex><span>print(num, text) <span style=color:#998;font-style:italic>-- will print &#39;42    &#34;some text&#34;&#39;</span>
</span></span></code></pre></div><p>Here, <code>ok</code> is a bool, which shows the status of coroutine. If <code>ok</code> is <code>true</code> then everything is okay and next returned values are arguments of the last <code>coroutine.yield</code> call. However, if <code>f</code> calls <code>error</code> function or fails at some point, the first value will be <code>false</code> and the error message will be the second return of the function. Let&rsquo;s see a failing coroutine:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> <span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>f</span>()
</span></span><span style=display:flex><span>  print(<span style=color:#099>1</span> <span style=font-weight:700>+</span> notDefined)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>c <span style=font-weight:700>=</span> coroutine.create(f)
</span></span><span style=display:flex><span>ok, msg <span style=font-weight:700>=</span> coroutine.resume(c)
</span></span><span style=display:flex><span><span style=font-weight:700>if</span> <span style=font-weight:700>not</span> ok <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>    print(<span style=color:#b84>&#34;Coroutine failed!&#34;</span>, msg)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Coroutine failed!
</span></span><span style=display:flex><span>input:4: attempt to perform arithmetic on a nil value <span style=font-weight:700>(</span>global ‘notDefined’<span style=font-weight:700>)</span>
</span></span></code></pre></div><p>Similarly, you can pass values to a coroutine when calling <code>coroutine.resume</code> and the results will be returned by <code>coroutine.yield</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> <span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>f</span>()
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    someNum <span style=font-weight:700>=</span> coroutine.yield()
</span></span><span style=display:flex><span>    print(someNum) <span style=color:#998;font-style:italic>-- will print &#34;42&#34;</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>coroutine.resume(c, <span style=color:#099>42</span>)
</span></span></code></pre></div><p>Coroutine can be in different states which you can check by calling <code>coroutine.status</code>:</p><ul><li><code>"running"</code> - coroutine is currently running. This means that <code>coroutine.status</code> was launched from inside the coroutine&rsquo;s function.</li><li><code>"suspended"</code> - coroutine was paused or hasn&rsquo;t been launched yet.</li><li><code>"normal"</code> - coroutine is active, but isn&rsquo;t currently running (it has resumed another coroutine).</li><li><code>"dead"</code> - the coroutine has finished running - function has finished its execution.</li></ul><p>Now, let&rsquo;s implement coroutine-based action sequence system with this knowledge.</p><h3 id=implementing-cutscenes-with-coroutines>Implementing cutscenes with coroutines</h3><p>Here&rsquo;s how our basic action will look like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>Action</span>:<span style=color:#900;font-weight:700>launch</span>()
</span></span><span style=display:flex><span>  self:init()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>while</span> <span style=font-weight:700>not</span> self.finished <span style=font-weight:700>do</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> dt <span style=font-weight:700>=</span> coroutine.yield() <span style=color:#998;font-style:italic>-- the most important part</span>
</span></span><span style=display:flex><span>    self:update(dt)
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  self:exit()
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>This is similar to what we have with action lists: the action calls <code>update</code> function until it&rsquo;s finished. But it yields on each game loop iteration (<code>Action:launch</code> is called from some coroutine), while somewhere in our main <code>update</code> (for example, in some <code>ActionSequenceManager</code> which tracks the state of all action sequences) we resume it like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>coroutine.resume(c, dt) <span style=color:#998;font-style:italic>-- note that we pass dt here</span>
</span></span><span style=display:flex><span>                        <span style=color:#998;font-style:italic>-- which is later used in actions&#39;s update</span>
</span></span></code></pre></div><p>Our cutscene is a coroutine now:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>cutscene</span>(player, npc)
</span></span><span style=display:flex><span>  player:goTo(npc)
</span></span><span style=display:flex><span>  npc:say(<span style=color:#b84>&#34;You did it!&#34;</span>)
</span></span><span style=display:flex><span>  delay(<span style=color:#099>0.5</span>)
</span></span><span style=display:flex><span>  npc:say(<span style=color:#b84>&#34;Thank you&#34;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- later...</span>
</span></span><span style=display:flex><span><span style=font-weight:700>local</span> c <span style=font-weight:700>=</span> coroutine.create(cutscene, player, npc)
</span></span><span style=display:flex><span>coroutine.resume(c, dt)
</span></span></code></pre></div><p>Here&rsquo;s how <code>delay</code> is implemented:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>delay</span>(time)
</span></span><span style=display:flex><span>    action <span style=font-weight:700>=</span> DelayAction:new { delay <span style=font-weight:700>=</span> time }
</span></span><span style=display:flex><span>    action:launch()
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>Having such wrapper functions is very useful to make your cutscenes easier to read and use. Next, let&rsquo;s see how <code>DelayAction</code> is implemented:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#998;font-style:italic>-- Action is a base class of DelayAction</span>
</span></span><span style=display:flex><span><span style=font-weight:700>local</span> DelayAction <span style=font-weight:700>=</span> class(<span style=color:#b84>&#34;DelayAction&#34;</span>, Action)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>DelayAction</span>:<span style=color:#900;font-weight:700>initialize</span>(params)
</span></span><span style=display:flex><span>  self.delay <span style=font-weight:700>=</span> params.delay
</span></span><span style=display:flex><span>  self.currentTime <span style=font-weight:700>=</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>  self.isFinished <span style=font-weight:700>=</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>DelayAction</span>:<span style=color:#900;font-weight:700>update</span>(dt)
</span></span><span style=display:flex><span>  self.currentTime <span style=font-weight:700>=</span> self.currentTime <span style=font-weight:700>+</span> dt
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> self.currentTime <span style=font-weight:700>&gt;=</span> self.delayTime <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>    self.finished <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>This is identical to action lists approach! Let&rsquo;s take a look at <code>Action</code>&rsquo;s <code>launch</code> function again to understand how it works:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>Action</span>:<span style=color:#900;font-weight:700>launch</span>()
</span></span><span style=display:flex><span>  self:init()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>while</span> <span style=font-weight:700>not</span> self.finished <span style=font-weight:700>do</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> dt <span style=font-weight:700>=</span> coroutine.yield() <span style=color:#998;font-style:italic>-- the most important part</span>
</span></span><span style=display:flex><span>    self:update(dt)
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  self:exit()
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>As you can see, we can create <code>init</code> and <code>exit</code> functions to do something when action begins and ends. But the most important part is the <code>while</code> loop which executes until the action is finished. Here&rsquo;s a visualization of the order of execution which makes it easier to understand:</p><figure><img src=coroutine-game-loop.png></figure><p>Now, let&rsquo;s see how we can implement <code>goTo</code> function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>Entity</span>:<span style=color:#900;font-weight:700>goTo</span>(target)
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> action <span style=font-weight:700>=</span> GoToAction:new { entity <span style=font-weight:700>=</span> self, target <span style=font-weight:700>=</span> target }
</span></span><span style=display:flex><span>    action:launch()
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>-- constructor is ommited</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>GoToAction</span>:<span style=color:#900;font-weight:700>update</span>(dt)
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> self.entity:closeTo(self.target) <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>      ... <span style=color:#998;font-style:italic>-- perform AI movement logic here</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>      self.finished <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>It&rsquo;s very easy to implement new types of actions.</p><p>Now, let&rsquo;s see how we can use coroutines with events. Let&rsquo;s implement <code>WaitForEventAction</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>WaitForEventAction</span>:<span style=color:#900;font-weight:700>initialize</span>(params)
</span></span><span style=display:flex><span>  self.finished <span style=font-weight:700>=</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  eventManager:subscribe {
</span></span><span style=display:flex><span>    listener <span style=font-weight:700>=</span> self,
</span></span><span style=display:flex><span>    eventType <span style=font-weight:700>=</span> params.eventType,
</span></span><span style=display:flex><span>    callback <span style=font-weight:700>=</span> WaitForEventAction.onEvent
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>WaitForEventAction</span>:<span style=color:#900;font-weight:700>onEvent</span>(event)
</span></span><span style=display:flex><span>  self.finished <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>We can leave the <code>update</code> function empty for that one. This action will execute until an event of <code>eventType</code> is sent. As a practical example of <code>WaitForEventAction</code> usage, let&rsquo;s implement <code>say</code> function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>Entity</span>:<span style=color:#900;font-weight:700>say</span>(text)
</span></span><span style=display:flex><span>    DialogueWindow:show(text)
</span></span><span style=display:flex><span>    <span style=font-weight:700>local</span> action <span style=font-weight:700>=</span> WaitForEventAction:new {
</span></span><span style=display:flex><span>      eventType <span style=font-weight:700>=</span> <span style=color:#b84>&#39;DialogueWindowClosed&#39;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    action:launch()
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>Nice and easy. Now, when dialogue window is closed by the player by the press of the button, it will send <code>DialogueWindowClosed</code> event. The action will finish and the next one will start.</p><p>It&rsquo;s easy to implement non-linear cutscenes, which depend on player&rsquo;s choice, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> answer <span style=font-weight:700>=</span> girl:say(<span style=color:#b84>&#39;do_you_love_lua&#39;</span>,
</span></span><span style=display:flex><span>                          { <span style=color:#b84>&#39;YES&#39;</span>, <span style=color:#b84>&#39;NO&#39;</span> })
</span></span><span style=display:flex><span><span style=font-weight:700>if</span> answer <span style=font-weight:700>==</span> <span style=color:#b84>&#39;YES&#39;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>  girl:setMood(<span style=color:#b84>&#39;happy&#39;</span>)
</span></span><span style=display:flex><span>  girl:say(<span style=color:#b84>&#39;happy_response&#39;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>  girl:setMood(<span style=color:#b84>&#39;angry&#39;</span>)
</span></span><span style=display:flex><span>  girl:say(<span style=color:#b84>&#39;angry_response&#39;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><figure><img src=dialogue.gif></figure><p>The implementation of <code>say</code> function is trickier there, because now you need to somehow return player&rsquo;s dialogue choice, but it&rsquo;s not that hard to implement. As you can see, we don&rsquo;t need to implement special mechanisms for if-else statements and loops.</p><h3 id=advanced-usage>Advanced usage</h3><p>It&rsquo;s easy to make quests and tutorials using coroutines. Consider this function:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>girl:say(<span style=color:#b84>&#34;Kill that monster!&#34;</span>)
</span></span><span style=display:flex><span>waitForEvent(<span style=color:#b84>&#39;EnemyKilled&#39;</span>)
</span></span><span style=display:flex><span>girl:setMood(<span style=color:#b84>&#39;happy&#39;</span>)
</span></span><span style=display:flex><span>girl:say(<span style=color:#b84>&#34;You did it! Thank you!&#34;</span>)
</span></span></code></pre></div><figure><img src=kill-monster-quest.gif></figure><p>You can also use coroutines for AI. For example, to make a monster traverse a path, you can do this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>followPath</span>(monster, path)
</span></span><span style=display:flex><span>  <span style=font-weight:700>local</span> numberOfPoints <span style=font-weight:700>=</span> path:getNumberOfPoints()
</span></span><span style=display:flex><span>  <span style=font-weight:700>local</span> i <span style=font-weight:700>=</span> <span style=color:#099>0</span> <span style=color:#998;font-style:italic>-- index of current waypoint on path</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>while</span> <span style=font-weight:700>true</span> <span style=font-weight:700>do</span>
</span></span><span style=display:flex><span>    monster:goTo(path:getPoint(i))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> i <span style=font-weight:700>&lt;</span> numberOfPoints <span style=font-weight:700>-</span> <span style=color:#099>1</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>      i <span style=font-weight:700>=</span> i <span style=font-weight:700>+</span> <span style=color:#099>1</span> <span style=color:#998;font-style:italic>-- go to the next point</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>else</span> <span style=color:#998;font-style:italic>-- start from the beginning</span>
</span></span><span style=display:flex><span>      i <span style=font-weight:700>=</span> <span style=color:#099>0</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><figure><img src=monster-follows-path.gif></figure><p>When monster will see the player, we can just not resume the coroutine, so while that <code>while</code> loop looks endless, it isn&rsquo;t.</p><p>It&rsquo;s also possible to implement &ldquo;parallel&rdquo; actions in a way that both actions are performed at the same time, but the action sequence goes to next action only when both actions are finished. For example, consider two NPCs moving at different speeds. When they meet at <code>meetingPoint</code>, the cat says &ldquo;meow&rdquo;. We can implement it like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#900;font-weight:700>cutscene</span>(cat, girl, meetingPoint)
</span></span><span style=display:flex><span>  <span style=font-weight:700>local</span> c1 <span style=font-weight:700>=</span> coroutine.create(
</span></span><span style=display:flex><span>    <span style=font-weight:700>function</span>()
</span></span><span style=display:flex><span>      cat:goTo(meetingPoint)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>local</span> c2 <span style=font-weight:700>=</span> coroutine.create(
</span></span><span style=display:flex><span>    <span style=font-weight:700>function</span>()
</span></span><span style=display:flex><span>      girl:goTo(meetingPoint)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  c1.resume()
</span></span><span style=display:flex><span>  c2.resume()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#998;font-style:italic>-- synchronization</span>
</span></span><span style=display:flex><span>  waitForFinish(c1, c2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#998;font-style:italic>-- cutscene continues</span>
</span></span><span style=display:flex><span>  cat:say(<span style=color:#b84>&#34;meow&#34;</span>)
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>The important part here is <code>waitForFinish</code> function which is a wrapper around <code>WaitForFinishAction</code> which can be implemented like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>function</span> <span style=color:#458;font-weight:700>WaitForFinishAction</span>:<span style=color:#900;font-weight:700>update</span>(dt)
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> coroutine.status(self.c1) <span style=font-weight:700>==</span> <span style=color:#b84>&#39;dead&#39;</span> <span style=font-weight:700>and</span>
</span></span><span style=display:flex><span>     coroutine.status(self.c2) <span style=font-weight:700>==</span> <span style=color:#b84>&#39;dead&#39;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>     self.finished <span style=font-weight:700>=</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> coroutine.status(self.c1) <span style=font-weight:700>~=</span> <span style=color:#b84>&#39;dead&#39;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>      coroutine.resume(self.c1, dt)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> coroutine.status(self.c2) <span style=font-weight:700>~=</span> <span style=color:#b84>&#39;dead&#39;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>      coroutine.resume(self.c2, dt)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>You can also take it a step further and allow <code>WaitForFinishAction</code> to take an arbitrary amount of actions to synchronize. You can also implement an action which waits until one of the actions is finished. For example, this can be used for racing mini-games. You&rsquo;ll be able to check when one of the cars arrives the finish line and then execute some action sequence.</p><h3 id=pros-and-cons-of-coroutines>Pros and cons of coroutines</h3><p>Coroutine approach is very powerful. The action sequences and cutscenes written with it can be easily read and modified, even by non-programmers.</p><p>What&rsquo;s also great is about it is that everything happens in one thread, so you don&rsquo;t have synchronization or data racing problems.</p><p>The approach is not perfect, however. For example, it&rsquo;s hard to handle saving. For example, suppose that you have a long tutorial which is just one big coroutine. The player won&rsquo;t be able to save during this tutorial, because you&rsquo;d have to serialize coroutine&rsquo;s state and then resume coroutine exactly from the point it was paused at.</p><p>This is not a problem if you use coroutines for cutscenes, as it&rsquo;s usually not allowed for player to save during them.</p><p>As for the long tutorial example - you can just separate your tutorial in chunks and then allow player to only save between them. For example, part A of the tutorial happens in a room without a save point. Then, there&rsquo;s another room with a save point to which player goes once part A is finished. Then, part B begins. If you separate tutorial into two coroutines, serializing won&rsquo;t be a problem, as you&rsquo;ll only need to save a string which will contain info about the point of tutorial which player has completed.</p><h2 id=conclusion>Conclusion</h2><p>As you can see, there are different approaches to implementing actions sequences and cutscenes. I believe coroutine approach is one of the most useful and clearest for writing action sequences and cutscenes. I hope this approach will make your life easier and you&rsquo;ll make tons of complex and fun cutscenes with it.</p><p>Thanks for reading!</p></article></main><footer id=footer>© 2022 Elias Daler. All rights reserved.<p>subscribe via <a href=https://eliasdaler.github.io/feed.xml>RSS</a></p></footer></body></html>