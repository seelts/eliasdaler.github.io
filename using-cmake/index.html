<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://eliasdaler.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=me href=https://mastodon.gamedev.place/web/@eliasdaler><link rel=alternate type=application/rss+xml href=https://eliasdaler.github.io/feed.xml title="Elias Daler's blog"><title>Using CMake and managing dependencies</title></head><body><header id=banner><h2><a href=https://eliasdaler.github.io>Elias Daler's blog</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>Using CMake and managing dependencies</h1><div>Publication date: <time>May 24, 2021</time></div><div></div></header><p>Building C++ projects and managing dependencies is hard. CMake&rsquo;s FetchContent makes it much more manageable and easy to do.</p><p>We&rsquo;ll go step by step and create a simple project which will have SFML, Dear ImGui and ImGui-SFML as its dependencies. The project will clone these dependencies&rsquo; source code from Github and build them. You won&rsquo;t need to use prebuilt libraries ever again.</p><p>I&rsquo;ll try to explain everything as I go on down to a &ldquo;basic&rdquo; things. It&rsquo;s good to understand everything you do and be able to do it from scratch without any guides. This article will also be a good starting point if you&rsquo;ve never used CMake before.</p><p>If you just want to learn how to manage dependencies with CMake with <code>FetchContent</code>, you can just jump straight to <a href=#adding-sfml-as-a-dependency>Adding SFML as a dependency</a> section.</p><p>The source code of the project in the article can be found <a href=https://github.com/eliasdaler/cmake-fetchcontent-tutorial-code>here</a>.</p><div><h2>Table Of Contents</h2><nav id=TableOfContents><ul><li><a href=#hello-world>Hello, world</a></li><li><a href=#building-a-project>Building a project</a></li><li><a href=#managing-dependencies>Managing dependencies</a><ul><li><a href=#manual-management>Manual management</a></li><li><a href=#git-submodules>Git submodules</a></li><li><a href=#package-managers>Package managers</a></li><li><a href=#fetchcontent>FetchContent</a></li></ul></li><li><a href=#adding-sfml-as-a-dependency>Adding SFML as a dependency</a></li><li><a href=#adding-dear-imgui-and-imgui-sfml-as-dependencies>Adding Dear ImGui and ImGui-SFML as dependencies</a></li><li><a href=#speeding-up-your-builds>Speeding up your builds</a></li><li><a href=#using-fetchcontent-with-local-source-directories>Using FetchContent with local source directories</a></li><li><a href=#some-notes-about-libraries-which-dont-behave-well>Some notes about libraries which don&rsquo;t behave well</a><ul><li><a href=#missing-or-poorly-written-cmake-build>Missing or poorly written CMake build</a></li><li><a href=#build_shared_libs>BUILD_SHARED_LIBS</a></li><li><a href=#copying-dlls-on-windows>Copying DLLs on Windows</a></li><li><a href=#find_package>find_package</a></li></ul></li><li><a href=#closing-thoughts>Closing thoughts</a></li></ul></nav></div><h2 id=hello-world>Hello, world</h2><p>First, let&rsquo;s create a bunch of files and directories so that we have a structure like this:</p><pre tabindex=0><code>.
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp
</code></pre><p>Let&rsquo;s start with a CMakeLists.txt from a root directory.</p><p>It&rsquo;s simple:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>cmake_minimum_required</span>(<span style=color:#b84>VERSION</span> <span style=color:#b84>3.15</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>project</span>(<span style=color:#b84>example</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>LANGUAGES</span> <span style=color:#b84>CXX</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>VERSION</span> <span style=color:#b84>1.0</span>
</span></span><span style=display:flex><span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>add_subdirectory</span>(<span style=color:#b84>src</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>The first line sets up a required minimal version of CMake which can be used to build the project. CMake constantly evolves and it&rsquo;s better to use the latest version for your project as each one brings handy new features, better compiler integration and bug fixes.</p><blockquote class=hint-info><p>If you&rsquo;re writing a library, it&rsquo;s better to stick to the lowest version of CMake that makes sense for you. You can find the version of CMake that is available for various distros <a href=https://repology.org/project/cmake/versions>here</a>. Another way of choosing is to look at other popular libraries and choose the same version.</p><p>For example, <a href=https://github.com/nlohmann/json>JSON for modern C++</a> and <a href=https://github.com/fmtlib/fmt>fmt</a> use CMake 3.1. I&rsquo;d recommend using something like CMake 3.8.2 or newer, unless you want to support very old distributions and users who don&rsquo;t want to upgrade to newer versions for some reason.</p></blockquote><p>After <code>cmake_minimum_required</code>, we have a project declaration:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>project</span>(<span style=color:#b84>example</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>LANGUAGES</span> <span style=color:#b84>CXX</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>VERSION</span> <span style=color:#b84>1.0</span>
</span></span><span style=display:flex><span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>The project is similar to a concept of &ldquo;solution&rdquo; in Visual Studio terminology. One project can have multiple &ldquo;targets&rdquo; (which roughly correspond to &ldquo;projects&rdquo; in VS). The target can be an executable, a library or even something which doesn&rsquo;t produce any files after it&rsquo;s built (e.g. it can run unit tests, linters and so on).</p><p><code>LANGUAGES</code> option in a <code>project</code> call defines a language which your project uses so that CMake knows what kind of builds to generate. By default it&rsquo;s <code>C</code> and <code>CXX</code>, but there are a lot of other options available for you (like <code>CUDA</code> or <code>Fortran</code>). If you&rsquo;re doing C or C++ project, it&rsquo;s optional to specify it, but it&rsquo;s still useful as a &ldquo;meta-data&rdquo; for people who&rsquo;re reading your CMake build.</p><p><code>VERSION</code> option specifies a current version of your project. It can be used to generate &ldquo;version&rdquo; headers (here&rsquo;s an <a href=https://cmake.org/cmake/help/v3.20/guide/tutorial/index.html#adding-a-version-number-and-configured-header-file>example</a> of how to do it), write some output in a terminal and so on. I&rsquo;ve seen a lot of people getting <code>VERSION</code> from a current Git tag or some changelog file, but we&rsquo;ll not go here in this tutorial.</p><p><code>add_subdirectory(&lt;DIR>)</code> is like an &ldquo;include&rdquo; and can be thought of as an inclusion of <code>&lt;DIR>/CMakeLists.txt</code> into another CMake file. It&rsquo;s actually a bit more complex, but it&rsquo;s okay to think about it as &ldquo;include&rdquo; at the beginning.</p><p>For example, if you have an examples directory, it&rsquo;s good to have a examples/CMakeLists.txt which will just be a bunch of add_subdirectory calls for each sub-directory and example/some_example/CMakeLists.txt will be a build script which contains information on how to build some_example.</p><p>Here&rsquo;s how <code>src/CMakeLists.txt</code> looks:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>add_executable</span>(<span style=color:#b84>example_exe</span> <span style=color:#b84>main.cpp</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Yep, just one line. Here, we define our first target, <code>example_exe</code>.</p><p>In the <code>add_executable</code> call, we can specify a list of sources needed to build your library or executable. For example, you can have:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>add_executable</span>(<span style=color:#b84>example_exe</span>
</span></span><span style=display:flex><span>    <span style=color:#b84>Game.cpp</span>
</span></span><span style=display:flex><span>    <span style=color:#b84>ResourceManager.cpp</span>
</span></span><span style=display:flex><span>    <span style=color:#b84>main.cpp</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Another option is to use <code>target_sources</code>, which can be especially helpful if your target has .cpp files in several subdirectories, e.g.:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#998;font-style:italic># in src/CMakeLists.txt
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#999>add_executable</span>(<span style=color:#b84>example_exe</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>add_subdirectory</span>(<span style=color:#b84>subdir</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>target_sources</span>(<span style=color:#b84>example_exe</span> <span style=color:#b84>PUBLIC</span> <span style=color:#b84>main.cpp</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#998;font-style:italic># in src/subdir/CMakeLists.txt
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#999>target_sources</span>(<span style=color:#b84>example_exe</span> <span style=color:#b84>source.cpp</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Read <a href=https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/>this post</a> to learn more <code>target_sources</code>.</p><p>Finally, our <code>main.cpp</code> looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#999;font-weight:700>#include</span> <span style=color:#999;font-weight:700>&lt;iostream&gt;</span><span style=color:#999;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#999;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>int</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    std<span style=font-weight:700>::</span>cout <span style=font-weight:700>&lt;&lt;</span> <span style=color:#b84>&#34;Hello, world!</span><span style=color:#b84>\n</span><span style=color:#b84>&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, let&rsquo;s build this project.</p><h2 id=building-a-project>Building a project</h2><p>Create a &ldquo;build directory&rdquo;. This is a directory where all temporary CMake, build and object files will be. It&rsquo;s also the directory in which your executables and libraries will be built (unless you tell CMake not to do so). Ideally, it should be outside of your &ldquo;source&rdquo; directory.</p><p>So, suppose you have a structure like this:</p><pre tabindex=0><code>cmake-example
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp
cmake-example-build
</code></pre><p>When you&rsquo;re in <code>cmake-example-build</code> directory (it&rsquo;s empty at the moment), do this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake ../cmake-example
</span></span></code></pre></div><p>This is the step where CMake does configuration (reading your CMake files, checking their validity, checking your compiler and so on) and generation of build files. If you&rsquo;re on Windows and only have Visual Studio installed, CMake will generate Visual Studio solutions/projects by default. On Linux it&rsquo;ll generate GNU Make <code>Makefile</code>s.</p><p>To specify a generator, simply pass a <code>-G</code> option with a name of your generator, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake -GNinja ../cmake-example
</span></span></code></pre></div><blockquote class=hint-info><a href=https://ninja-build.org/>ninja</a> is a great build tool. It&rsquo;s blazingly fast and I find that it performs better than GNU Make for me in most cases.</blockquote><p>Here&rsquo;s an example output of configuration and generation if it goes right:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>-- The CXX compiler identification is GNU 9.3.0
</span></span><span style=display:flex><span>-- Check <span style=font-weight:700>for</span> working CXX compiler: /usr/bin/c++
</span></span><span style=display:flex><span>-- Check <span style=font-weight:700>for</span> working CXX compiler: /usr/bin/c++ -- works
</span></span><span style=display:flex><span>-- Detecting CXX compiler ABI info
</span></span><span style=display:flex><span>-- Detecting CXX compiler ABI info - <span style=font-weight:700>done</span>
</span></span><span style=display:flex><span>-- Detecting CXX compile features
</span></span><span style=display:flex><span>-- Detecting CXX compile features - <span style=font-weight:700>done</span>
</span></span><span style=display:flex><span>-- Configuring <span style=font-weight:700>done</span>
</span></span><span style=display:flex><span>-- Generating <span style=font-weight:700>done</span>
</span></span><span style=display:flex><span>-- Build files have been written to: ...
</span></span></code></pre></div><p>Finally, let&rsquo;s build the project:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake --build .
</span></span></code></pre></div><p>You can also build a specific target if you run</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake --build . --target &lt;target_name&gt;
</span></span></code></pre></div><p>, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake --build . --target example_exe
</span></span></code></pre></div><p>You&rsquo;ll find the executable in <code>&lt;your-build-dir>/src/</code> directory or <code>&lt;your-build-dir>/Debug/src</code> if you&rsquo;re using Visual Studio to build the project.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ ./src/example_exe
</span></span><span style=display:flex><span>Hello, world!
</span></span></code></pre></div><blockquote class=hint-info>If you&rsquo;ve generated a Visual Studio solution, you can just use Visual Studio for building. It even checks if any CMakeLists.txt was modified and re-generates solution/project which changed. You&rsquo;ll see VS asking if it should reload the project which has changed - you should agree do it so that it works properly.</blockquote><p>If the target you&rsquo;re building is a library, CMake will build a static one by default. To build a shared library, set <code>BUILD_SHARED_LIBS=ON</code> like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake -DBUILD_SHARED_LIBS<span style=font-weight:700>=</span>ON &lt;source-dir&gt;
</span></span></code></pre></div><p>Some generators (Visual Studio and XCode) support building multiple configurations of your projects in one build directory. You can do it by specifying <code>--config</code> flag during the build like so:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake --build . --target some_target --config Release
</span></span></code></pre></div><p>If in Ninja, GNU make and so on, your <code>example_exe</code> will be located in <code>&lt;build-dir>/src/</code>, in Visual Studio it will be localted in <code>&lt;build-dir>/src/&lt;config>/</code> (e.g. <code>&lt;build-dir>/src/Release</code>).</p><p>For generators which don&rsquo;t support multi-configuration builds in one build directory, you&rsquo;ll have to make multiple build directories for each build type.</p><h2 id=managing-dependencies>Managing dependencies</h2><p>There are a lot of ways of managing dependencies with CMake, so let&rsquo;s to a quick overview of possible ways.</p><h3 id=manual-management>Manual management</h3><p>The simplest way of doing dependency management is to simply copy source code of your dependencies into your project source directory. For example, you can just copy SFML sources to your <code>&lt;source-dir>/dependencies/SFML</code> and then just do <code>add_subdirectory(dependencies/SFML)</code> in your main CMake file (and then link to SFML&rsquo;s targets as needed)</p><p>However, this is not the best way of doing it:</p><ul><li>It might be hard to know which exact version the dependencies are.</li><li>You also don&rsquo;t get a clear picture if you&rsquo;ve modified the dependencies&rsquo; sources (e.g. to fix some problem or by mistake when you refactored something). Updating them is not fun then.</li><li>Your source directory might become huge if you have a lot of dependencies (and the repo size might increase dramatically as well).</li></ul><h3 id=git-submodules>Git submodules</h3><p>Git submodules are basically pointers to other repositories. The pointer basically stores repo&rsquo;s URL and the commit you choose to point at (e.g. commit of a specific library version).</p><p>You can directly use <code>add_subdirectory(...)</code> with dependencies referenced via submodules, but you&rsquo;ll need to check via CMake that dependencies were cloned, otherwise you&rsquo;ll get errors about CMake not being able to find referenced subdirectories.</p><p>You can read more about Git submodules <a href=https://git-scm.com/book/en/v2/Git-Tools-Submodules>here</a>. I don&rsquo;t use them myself, as I don&rsquo;t like the git&rsquo;s commands for their management and the metadata about your dependencies is not as clear as it could be.</p><p>But still, it&rsquo;s a thing that works for a lot of people (and I&rsquo;ve seen many libraries/application going with it), so it might work for you well.</p><h3 id=package-managers>Package managers</h3><p>There&rsquo;s a bunch of package managers available for C++ right now: Conan, vcpkg and so on. They can be a great way of managing dependencies.</p><p>I don&rsquo;t like them for a few reasons.</p><p>There&rsquo;s no standard package manager in C++ world as of today, which leads to a fragmentation and build scripts not being available for all your dependencies. These build scripts are not supported by library maintainers most of the time, which leads to them to quickly becoming out of date with the latest version of the library or having some build features not being available to you.</p><p>And finally, I like having few dependencies. I only need Git, a C++ compiler and CMake for building things I write.</p><h3 id=fetchcontent>FetchContent</h3><p>This is the way of managing dependencies that I personally use and like a lot.</p><blockquote class=hint-info><strong>Update (2022)</strong>. Not anymore, I started using git submodules. FetchContent is still fantastic for quick/simple stuff, though!</blockquote><p>Basically, it allows you to download or clone source code of external projects from the Web (or other source) and then use this sources via <code>add_subdirectory</code> call and linking to dependency&rsquo;s targets or other means.</p><p>It&rsquo;s a wrapper around <code>ExternalProject</code> CMake command, which can do a lot of things:</p><ul><li>It can download or git clone other project sources</li><li>Configure and build them</li><li>Run some commands at various steps of build process</li></ul><p>A typical <code>ExternalProject</code> declaration looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>ExternalProject_Add</span>(<span style=color:#b84>foobar</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_REPOSITORY</span>    <span style=color:#b84>git@github.com:FooCo/FooBar.git</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_TAG</span>           <span style=color:#b84>origin/release/1.2.3</span>
</span></span><span style=display:flex><span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>The problem with it was that it did download at <strong>build</strong> time, which doesn&rsquo;t allow you to link to your dependencies targets - you need to link to library files produced after the build like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>target_include_directories</span>(<span style=color:#b84>your_target</span> <span style=color:#b84>PRIVATE</span> <span style=color:#b84>&lt;path-to-foorbar-includes&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b84>target_link_libraries(your_target</span> <span style=color:#b84>PRIVATE</span> <span style=color:#b84>&lt;path-to-a-build-foorbar-library&gt;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>This wasn&rsquo;t convenient, as a lot of dependencies build internals spilled into your build files and you needed to do a lot more work than simply linking to dependencies&rsquo; targets.</p><p><code>FetchContent</code> solves that problem by downloading the dependency at <strong>configure</strong> time, which allows you to do this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>FetchContent_Declare</span>(<span style=color:#b84>foobar</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_REPOSITORY</span>    <span style=color:#b84>git@github.com:FooCo/FooBar.git</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_TAG</span>           <span style=color:#b84>origin/release/1.2.3</span>
</span></span><span style=display:flex><span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>FetchContent_MakeAvailable</span>(<span style=color:#b84>foobar</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#998;font-style:italic># somewhere later...
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#999>target_link_libraries</span>(<span style=color:#b84>your_target</span> <span style=color:#b84>PRIVATE</span> <span style=color:#b84>foobar_target</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>There are some downsides to using FetchContent, however:</p><ul><li>Your initial configuration step might take a lot of time if you have a lot of dependencies, because some repos might take a lot of time to download (it can take minutes!). However, with <code>ExternalProject</code> you can get the same problem, but during the build process instead.</li><li>Some libraries might depend on other libraries being built and installed on the system. They will use <code>find_package</code> or <code>find_library</code> to find them and this might cause some problems for you. I&rsquo;ll talk about it <a href=#find_package>find_package</a> section of this article in more detail.</li></ul><h2 id=adding-sfml-as-a-dependency>Adding SFML as a dependency</h2><p>Create <code>depedencies/CMakeLists.txt</code> and <code>dependencies/sfml/CMakeLists.txt</code>. We have the following structure now:</p><pre tabindex=0><code>.
├── CMakeLists.txt
├── dependencies
│   ├── CMakeLists.txt
│   └── sfml
│       └── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp
</code></pre><blockquote class=hint-info>I like naming dependencies and their directories in lowercase, because it allows me to not have to not think if the third-party dependency directory is named &ldquo;openAL&rdquo;, &ldquo;OpenAL&rdquo; - it&rsquo;ll be just &ldquo;openal&rdquo;. &ldquo;ImGui-SFML&rdquo; will be &ldquo;imgui-sfml&rdquo;.</blockquote><p>First, let&rsquo;s add <code>add_subdirectory(dependencies)</code> to our root <code>CMakeLists.txt</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#998;font-style:italic># ...
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>add_subdirectory</span>(<span style=color:#b84>dependencies</span>) <span style=color:#998;font-style:italic># add this
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#999>add_subdirectory</span>(<span style=color:#b84>src</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>The <code>dependencies/CMakeLists.txt</code> looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>include</span>(<span style=color:#b84>FetchContent</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>FetchContent_Declare</span>(
</span></span><span style=display:flex><span>  <span style=color:#b84>sfml</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_REPOSITORY</span> <span style=color:#b84>&#34;https://github.com/SFML/SFML&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_TAG</span> <span style=color:#b84>2f11710abc5aa478503a7ff3f9e654bd2078ebab</span> <span style=color:#998;font-style:italic># 2.5.1
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>add_subdirectory</span>(<span style=color:#b84>sfml</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Note that you can specify <code>GIT_TAG</code> by the name and not by the commit hash, but referencing by commit hash makes <code>FetchContent</code> quicker, because it doesn&rsquo;t have to connect the remote to check if the tag hasn&rsquo;t been modified.</p><p>Next, <code>dependencies/sfml/CMakeLists.txt</code> (I&rsquo;ll explain what goes on here a bit later):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>message</span>(<span style=color:#b84>STATUS</span> <span style=color:#b84>&#34;Fetching SFML...&#34;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#998;font-style:italic># No need to build audio and network modules
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#999>set</span>(<span style=color:#b84>SFML_BUILD_AUDIO</span> <span style=color:#b84>FALSE</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>set</span>(<span style=color:#b84>SFML_BUILD_NETWORK</span> <span style=color:#b84>FALSE</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>FetchContent_MakeAvailable</span>(<span style=color:#b84>sfml</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p><code>src/CMakeLists.txt</code> looks like this now:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>add_executable</span>(<span style=color:#b84>example_exe</span> <span style=color:#b84>main.cpp</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>target_link_libraries</span>(<span style=color:#b84>example_exe</span> <span style=color:#b84>PRIVATE</span> <span style=color:#b84>sfml-graphics</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>And finally, let&rsquo;s change our <code>src/main.cpp</code> to the following &ldquo;SFML Hello world&rdquo; code which is used in its many examples:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#999;font-weight:700>#include</span> <span style=color:#999;font-weight:700>&lt;SFML/Graphics.hpp&gt;</span><span style=color:#999;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#999;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>int</span> <span style=color:#900;font-weight:700>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sf<span style=font-weight:700>::</span>RenderWindow window(sf<span style=font-weight:700>::</span>VideoMode(<span style=color:#099>200</span>, <span style=color:#099>200</span>), <span style=color:#b84>&#34;SFML works!&#34;</span>);
</span></span><span style=display:flex><span>    sf<span style=font-weight:700>::</span>CircleShape shape(<span style=color:#099>100.f</span>);
</span></span><span style=display:flex><span>    shape.setFillColor(sf<span style=font-weight:700>::</span>Color<span style=font-weight:700>::</span>Green);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>while</span> (window.isOpen())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sf<span style=font-weight:700>::</span>Event event;
</span></span><span style=display:flex><span>        <span style=font-weight:700>while</span> (window.pollEvent(event))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> (event.type <span style=font-weight:700>==</span> sf<span style=font-weight:700>::</span>Event<span style=font-weight:700>::</span>Closed)
</span></span><span style=display:flex><span>                window.close();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        window.clear();
</span></span><span style=display:flex><span>        window.draw(shape);
</span></span><span style=display:flex><span>        window.display();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> <span style=color:#099>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you&rsquo;re building on Windows, run the generation step again and set <code>BUILD_SHARED_LIBS</code> to <code>OFF</code> so that SFML doesn&rsquo;t make it <code>ON</code> causing issues with DLLs.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake -DBUILD_SHARED_LIBS<span style=font-weight:700>=</span>OFF &lt;source-dir&gt;
</span></span></code></pre></div><p>More about this in <a href=#copying-dlls-on-windows>&ldquo;Copying DLLs on Windows&rdquo;</a> section.</p><p>Now, let&rsquo;s build the project:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake --build .
</span></span></code></pre></div><p>A lot of the time can pass after &ldquo;Fetching SFML&mldr;&rdquo; message is displayed (even a minute or so).</p><p>This is normal and can be caused by your Internet connection, GitHub being slow, or older versions of CMake where <code>FetchContent</code> is not as quick as it can be (the developers seem to be working on its speed, so try to use the oldest version of CMake).</p><p>A lot of dependencies can be downloaded much quicker if you download a release zip instead, for example for SFML we can do this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>FetchContent_Declare</span>(
</span></span><span style=display:flex><span>  <span style=color:#b84>sfml</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>URL</span> <span style=color:#b84>https://github.com/SFML/SFML/archive/refs/tags/2.5.1.zip</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>URL_HASH</span> <span style=color:#b84>2c4438b3e5b2d81a6e626ecf72bf75be</span>
</span></span><span style=display:flex><span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>It&rsquo;s also a good idea to specify <code>URL_HASH</code> here to not download anything which you didn&rsquo;t expect. You can usually find md5 hash or release in release notes or calculate it yourself using <code>md5sum</code>.</p><p>Finally, run <code>src/example_exe</code> and you&rsquo;ll see this:</p><figure><img src=sfml-simple.png></figure><p>Now, let&rsquo;s see what&rsquo;s going on in <code>dependencies/sfml/CMakeLists.txt</code>.</p><p>First of all, we have a message which just prints &ldquo;Fetching SFML&mldr;&rdquo;:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>message</span>(<span style=color:#b84>&#34;Fetching SFML...&#34;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>You can also have it say where it will fetch SFML from, at which commit, which version, etc. Having something printed there is useful, because otherwise you&rsquo;ll not be able to take which dependency takes a lot of time to download (or fails at configuration step). However, it will also print it every time you run a generation step, even if nothing will get downloaded. I think it&rsquo;s not a big deal.</p><p>Then, we have a couple of <code>set</code> calls which need to be done before <code>FetchContent_MakeAvailable</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>set</span>(<span style=color:#b84>SFML_BUILD_AUDIO</span> <span style=color:#b84>FALSE</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>set</span>(<span style=color:#b84>SFML_BUILD_NETWORK</span> <span style=color:#b84>FALSE</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><hr><p>A lot of libraries allow you to modify their behaviour and build process by setting CMake variables. CMake has a complex way of how <code>option</code> and <code>set(... CACHE ...)</code> behave depending on if you have defined the variable or not. Sometimes a simple <code>set</code> is not enough and you&rsquo;ll need to do a <code>set(... CACHE ...)</code> and even <code>set(... CACHE ... FORCE)</code> to stop dependency&rsquo;s CMakeLists.txt from overwriting the variable you&rsquo;re trying to set.</p><blockquote class=hint-info>It&rsquo;s a good practice to take a look at what gets built by default in your dependencies and tell CMake to build only what you need from the dependency (some libraries can build examples, docs and tests by default, which you probably don&rsquo;t need).</blockquote><p>Finally, we call <code>FetchContent_MakeAvailable</code> which basically does some internal <code>FetchContent</code> variable and then calls <code>add_subdirectory</code> for the directory it has downloaded making dependency&rsquo;s targets available to you.</p><blockquote class=hint-info>The source files of SFML can now be found in <code>*build_dir*/_deps/sfml-src</code>, SFML&rsquo;s build directory and produced binaries can be found in <code>*build_dir*/_deps/sfml-build</code>.</blockquote><h2 id=adding-dear-imgui-and-imgui-sfml-as-dependencies>Adding Dear ImGui and ImGui-SFML as dependencies</h2><p>Now, let&rsquo;s look at something more complicated.</p><p>I want to add <a href=https://github.com/eliasdaler/imgui-sfml>ImGui-SFML</a> as a dependency - it&rsquo;s the library that allows you to easily integrate <a href=https://github.com/ocornut/imgui>Dear ImGui</a> and SFML. Let&rsquo;s add Dear ImGui as a dependency first.</p><p>Add this to <code>dependencies/CMakeLists.txt</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>FetchContent_Declare</span>(
</span></span><span style=display:flex><span>  <span style=color:#b84>imgui</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_REPOSITORY</span> <span style=color:#b84>https://github.com/ocornut/imgui</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_TAG</span> <span style=color:#b84>35b1148efb839381b84de9290d9caf0b66ad7d03</span>
</span></span><span style=display:flex><span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>FetchContent_MakeAvailable</span>(<span style=color:#b84>imgui</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Dear ImGui doesn&rsquo;t have a CMake build for the time of writing. We still need to call <code>FetchContent_MakeAvailable</code>, though, so that we get <code>imgui_SOURCE_DIR</code> variable set which we&rsquo;ll use when setting up ImGui-SFML in a moment.</p><p>Next, let&rsquo;s add ImGui-SFML to <code>dependencies/CMakeLists.txt</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>FetchContent_Declare</span>(
</span></span><span style=display:flex><span>  <span style=color:#b84>imgui-sfml</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_REPOSITORY</span> <span style=color:#b84>https://github.com/eliasdaler/imgui-sfml</span>
</span></span><span style=display:flex><span>  <span style=color:#b84>GIT_TAG</span> <span style=color:#b84>82dc2033e51b8323857c3ae1cf1f458b3a933c35</span>
</span></span><span style=display:flex><span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>add_subdirectory</span>(<span style=color:#b84>imgui-sfml</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Next, we&rsquo;ll create <code>dependency/imgui-sfml/CMakeLists.txt</code>, which looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>message</span>(<span style=color:#b84>STATUS</span> <span style=color:#b84>&#34;Fetching ImGui-SFML...&#34;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>set</span>(<span style=color:#b84>IMGUI_DIR</span> <span style=font-weight:700>${</span><span style=color:teal>imgui_SOURCE_DIR</span><span style=font-weight:700>}</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>set</span>(<span style=color:#b84>IMGUI_SFML_FIND_SFML</span> <span style=color:#b84>OFF</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>set</span>(<span style=color:#b84>IMGUI_SFML_IMGUI_DEMO</span> <span style=color:#b84>ON</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>FetchContent_MakeAvailable</span>(<span style=color:#b84>imgui-sfml</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Nothing special - we need to set <code>IMGUI_DIR</code> to a place where Dear ImGui sources can be found and set <code>IMGUI_SFML_FIND_SFML</code> to <code>OFF</code> so that ImGui-SFML doesn&rsquo;t attempt to call <code>find_package(SFML)</code> which will fail (more about that in <code>find_package</code> section a bit later).</p><p>Note that <code>add_subdirectory(imgui-sfml)</code> should be place before <code>FetchContent_MakeAvailable(imgui)</code> call so that <code>imgui_SOURCE_DIR</code> gets defined.</p><p>Next, let&rsquo;s change the contents of <code>src/main.cpp</code> to the following:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#999;font-weight:700>#include</span> <span style=color:#999;font-weight:700>&lt;SFML/Graphics/RenderWindow.hpp&gt;</span><span style=color:#999;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#999;font-weight:700>#include</span> <span style=color:#999;font-weight:700>&lt;SFML/System/Clock.hpp&gt;</span><span style=color:#999;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#999;font-weight:700>#include</span> <span style=color:#999;font-weight:700>&lt;SFML/Window/Event.hpp&gt;</span><span style=color:#999;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#999;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#999;font-weight:700>#include</span> <span style=color:#999;font-weight:700>&lt;imgui-SFML.h&gt;</span><span style=color:#999;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#999;font-weight:700>#include</span> <span style=color:#999;font-weight:700>&lt;imgui.h&gt;</span><span style=color:#999;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#999;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#458;font-weight:700>int</span> <span style=color:#900;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>    sf<span style=font-weight:700>::</span>RenderWindow window(sf<span style=font-weight:700>::</span>VideoMode(<span style=color:#099>1280</span>, <span style=color:#099>720</span>), <span style=color:#b84>&#34;ImGui + SFML = &lt;3&#34;</span>);
</span></span><span style=display:flex><span>    window.setFramerateLimit(<span style=color:#099>60</span>);
</span></span><span style=display:flex><span>    ImGui<span style=font-weight:700>::</span>SFML<span style=font-weight:700>::</span>Init(window);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sf<span style=font-weight:700>::</span>Clock deltaClock;
</span></span><span style=display:flex><span>    <span style=font-weight:700>while</span> (window.isOpen()) {
</span></span><span style=display:flex><span>        sf<span style=font-weight:700>::</span>Event event;
</span></span><span style=display:flex><span>        <span style=font-weight:700>while</span> (window.pollEvent(event)) {
</span></span><span style=display:flex><span>            ImGui<span style=font-weight:700>::</span>SFML<span style=font-weight:700>::</span>ProcessEvent(event);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> (event.type <span style=font-weight:700>==</span> sf<span style=font-weight:700>::</span>Event<span style=font-weight:700>::</span>Closed) {
</span></span><span style=display:flex><span>                window.close();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ImGui<span style=font-weight:700>::</span>SFML<span style=font-weight:700>::</span>Update(window, deltaClock.restart());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ImGui<span style=font-weight:700>::</span>ShowDemoWindow();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        window.clear();
</span></span><span style=display:flex><span>        ImGui<span style=font-weight:700>::</span>SFML<span style=font-weight:700>::</span>Render(window);
</span></span><span style=display:flex><span>        window.display();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ImGui<span style=font-weight:700>::</span>SFML<span style=font-weight:700>::</span>Shutdown();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> <span style=color:#099>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a &ldquo;hello world&rdquo; of ImGui-SFML - it calls all the necessary functions for ImGui-SFML to do its thing and calls <code>ImGui::ShowDemoWindow</code> which is a great way to see how many things Dear ImGui can do.</p><p>Finally, we change <code>target_link_libraries</code> call in <code>src/CMakeLists.txt</code> to the following:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>target_link_libraries</span>(<span style=color:#b84>example_exe</span> <span style=color:#b84>PRIVATE</span> <span style=color:#b84>ImGui-SFML::ImGui-SFML</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Yep, that&rsquo;s it! Notice that the implicit linking to the <code>sfml-graphics</code> is gone - ImGui-SFML links to it in its build files, so now you don&rsquo;t need to link to SFML directly.</p><p>Finally, let&rsquo;s build our program and you&rsquo;ll see something like this (I opened a few menus to make the screenshot more interesting).</p><figure><img src=imgui-sfml.png></figure><h2 id=speeding-up-your-builds>Speeding up your builds</h2><p>Of course, having to rebuild dependencies from scratch can take a lot of time. There&rsquo;s a simple solution to that: <a href=https://github.com/ccache/ccache>ccache</a>. This amazing program will cache all the object files you build and then instead of compiling the same source file from scratch over and over, it&rsquo;ll just use the cached object file instead of doing compilation.</p><p>It works with Clang and GCC and a couple of other compilers. MSVC is not supported, unfortunately.</p><p>To use it, simply install it somewhere on your system and then do this on CMake configuration step:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake ... --DCMAKE_CXX_COMPILER_LAUNCHER<span style=font-weight:700>=</span>ccache ...
</span></span></code></pre></div><p>You can also add this to your CMake builds to not have to set <code>CMAKE_CXX_COMPILER_LAUNCHER</code> manually every time:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>find_program</span>(<span style=color:#b84>CCACHE_FOUND</span> <span style=color:#b84>ccache</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>if</span>(<span style=color:#b84>CCACHE_FOUND</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span>  <span style=color:#999>set_property</span>(<span style=color:#b84>GLOBAL</span> <span style=color:#b84>PROPERTY</span> <span style=color:#b84>RULE_LAUNCH_COMPILE</span> <span style=color:#b84>ccache</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>endif</span>(<span style=color:#b84>CCACHE_FOUND</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><h2 id=using-fetchcontent-with-local-source-directories>Using FetchContent with local source directories</h2><p>Sometimes it can be useful to download sources for dependencies and have FetchContent use them instead of fetching them from the Web. This can be needed for a few reasons:</p><ul><li>You don&rsquo;t want to download sources again and again when you remove your build directories</li><li>You&rsquo;re going somewhere where Internet connection is poor or not available</li><li>You want to do some source changes and see how the dependency will behave with them.</li></ul><p>This is easy to do. Just set <code>FETCHCONTENT_SOURCE_DIR_&lt;lib></code> to your dependency source dir and you&rsquo;re done, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cmake -DFETCHCOUNTENT_SOURCE_DIR_SFML<span style=font-weight:700>=</span>&lt;sfml-dir&gt; &lt;main-project-source-dir&gt;
</span></span></code></pre></div><p>Note that even if your library is named <code>sfml</code> in CMake, you&rsquo;ll need to set <code>FETCHCONTENT_SOURCE_DIR_SFML</code> and not <code>FETCHCONTENT_SOURCE_DIR_sfml</code>.</p><h2 id=some-notes-about-libraries-which-dont-behave-well>Some notes about libraries which don&rsquo;t behave well</h2><p>In the example I&rsquo;ve showed you, everything went pretty well. In most cases it won&rsquo;t - you&rsquo;ll spend a lot more time trying to get the library to work with your project, so let&rsquo;s look at some common cases.</p><h3 id=missing-or-poorly-written-cmake-build>Missing or poorly written CMake build</h3><p>Not all libraries are built with CMake, Dear ImGui and Lua being examples. In some cases, there&rsquo;s a CMake build, but it can be outdated or written in older CMake which makes build targets essentially useless (e.g. instead of <code>target_include_libraries</code> which carry transitive include directory dependencies, the library can use <code>include_directories</code> which will force you to manually specify include directories and other things for the library you link to).</p><p>There are several ways of handling this:</p><ul><li>The best, but most complicated way is to fork the project, fix the CMake build and submit a PR. Until the PR is merged, you point <code>FetchContent</code> to the branch of your fork and wait. It&rsquo;s difficult, but it helps a lot of people in the future. I&rsquo;ve done it myself and noticed that CMake builds of the libraries I use (SDL, for example) have improved gradually over the years thanks to other people&rsquo;s contributions</li><li>Use some &ldquo;alternative&rdquo; CMake build/fork of a library. For example, for Lua I use <a href=https://github.com/LuaDist/lua>this repo</a> and for GLEW, I use <a href=https://github.com/Perlmint/glew-cmake>this one</a>.</li><li>You can use <code>FetchContent</code> for getting source code of the library and then write the needed CMake build code from scratch as I&rsquo;ve done in <a href=https://github.com/eliasdaler/imgui-fetchcontent>this example</a> of using Dear ImGui with SDL with FetchContent.</li></ul><h3 id=build_shared_libs>BUILD_SHARED_LIBS</h3><p>A lot of libraries tend to ignore <code>BUILD_SHARED_LIBS</code> and either build shared libraries by default or build both static and shared library unless you tell it not to do that. You&rsquo;ll probably need to look at your dependency&rsquo;s <code>CMakeList.txt</code> to understand how to build a static or shared library depending on your needs.</p><p>In SFML&rsquo;s case, if you don&rsquo;t set <code>BUILD_SHARED_LIBS</code> to <code>OFF</code>, it&rsquo;ll just build shared libraries, which is a bit frustrating. To fix this, you&rsquo;ll need to set <code>BUILD_SHARED_LIBS</code> to <code>OFF</code> if you need to build SFML as static libraries.</p><h3 id=copying-dlls-on-windows>Copying DLLs on Windows</h3><p>If you&rsquo;re using dynamic linking when building on Windows, you&rsquo;ll need to copy DLLs to the directory where your executable is built, so that it can find them. This can be done by adding the following:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#998;font-style:italic># Copy DLLs needed for runtime on Windows
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#999>if</span>(<span style=color:#b84>WIN32</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span>  <span style=color:#999>if</span> (<span style=color:#b84>BUILD_SHARED_LIBS</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span>    <span style=color:#999>add_custom_command</span>(<span style=color:#b84>TARGET</span> <span style=color:#b84>example_exe</span> <span style=color:#b84>POST_BUILD</span>
</span></span><span style=display:flex><span>      <span style=color:#b84>COMMAND</span> <span style=font-weight:700>${</span><span style=color:teal>CMAKE_COMMAND</span><span style=font-weight:700>}</span> <span style=color:#b84>-E</span> <span style=color:#b84>copy_if_different</span>
</span></span><span style=display:flex><span>          <span style=font-weight:700>$&lt;</span><span style=color:teal>TARGET_FILE:ImGui-SFML::ImGui-SFML</span><span style=font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>          <span style=font-weight:700>$&lt;</span><span style=color:teal>TARGET_FILE:sfml-graphics</span><span style=font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>          <span style=font-weight:700>$&lt;</span><span style=color:teal>TARGET_FILE:sfml-window</span><span style=font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>          <span style=font-weight:700>$&lt;</span><span style=color:teal>TARGET_FILE:sfml-system</span><span style=font-weight:700>&gt;</span>
</span></span><span style=display:flex><span>          <span style=font-weight:700>$&lt;</span><span style=color:teal>TARGET_FILE_DIR:example_exe</span><span style=font-weight:700>&gt;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span>  <span style=color:#999>endif</span>()<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>endif</span>()<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>Basically, CMake will take build artifacts of <code>ImGui-SFML</code>, <code>sfml-graphics</code>, <code>sfml-window</code> and <code>sfml-system</code> targets (DLLs) and copy them to the directory where executable <code>example_exe</code> will be built. Note that this is only done when you&rsquo;re building your project, not installing it (when you run <code>cmake --build . --target install</code>). For that, you&rsquo;ll need to add similar install steps to your build script.</p><h3 id=find_package>find_package</h3><p>If your dependency depends on other dependencies and uses <code>find_package</code> to find them, this can lead to a lot of problems, because in some cases, <code>find_package</code> tries to find built library files and does it in system directories. If you don&rsquo;t have this library built or installed system-wide, <code>find_package</code> will fail, even though you build the dependency of dependency yourself. This issue is still not solved and discussion about it can be found <a href=https://gitlab.kitware.com/cmake/cmake/-/issues/17735>here</a>.</p><p>To handle this, make a PR or ask a library maintainer to add an option to skip <code>find_package</code> call if some option like <code>XXX_FIND_Y</code> is set to <code>FALSE</code>. For example, ImGui-SFML will not call <code>find_package(SFML)</code> if <code>IMGUI_SFML_FIND_SFML</code> is set to <code>FALSE</code>. Another way to make your library more friendly is to check if the targets you want to link to are already present, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#999>if</span> (<span style=color:#b84>NOT</span> <span style=color:#b84>TARGET</span> <span style=color:#b84>&lt;target_of_dependency&gt;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span>  <span style=color:#999>find_package</span>(<span style=color:#b84>&lt;dependency&gt;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>endif</span>()<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#998;font-style:italic># ...
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#999>target_link_libraries</span>(<span style=color:#b84>&lt;target&gt;</span> <span style=color:#b84>PUBLIC</span> <span style=color:#b84>&lt;target_of_dependency&gt;</span>)<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></div><p>I did this to fix SDL_image not behaving well with its dependency on SDL which can be seen in <a href=https://github.com/libsdl-org/SDL_image/pull/170>this PR</a>.</p><p>If you can&rsquo;t do that for some reason, you&rsquo;ll have to use <code>ExternalProject</code>. For example, if libA depends on libB and uses <code>find_package</code> to find libB, then you need to to build and install <code>libB</code> first via <code>ExternalProject</code> and only then build <code>libA</code>&rsquo;s so that <code>find_package(libB)</code> succeeds. This is very complicated, which makes the first solution (modifying the CMakeLists.txt which calls <code>find_package</code> via any means) much easier in practice.</p><h2 id=closing-thoughts>Closing thoughts</h2><p>CMake is quite complex, and I think I only scratched the surface of how to manage a CMake project and its dependencies. However, I hope that you&rsquo;ve found this article useful and it&rsquo;ll be a good step to get you started and make your builds easier to manage.</p><p>Here are some recommended CMake resources to help you further:</p><ul><li><a href=https://crascit.com/professional-cmake/>Professional CMake: A Practical Guide</a> by Craig Scott. The best and most up-to-date book about CMake. It will teach you most of the things you&rsquo;ll ever need from CMake. I use it as a CMake reference all the time.</li><li><a href=https://cmake.org/cmake/help/v3.20/guide/tutorial/index.html>CMake tutorial</a> and <a href=https://cmake.org/cmake/help/v3.20/manual/cmake-buildsystem.7.html>cmake-buildsystem(7)</a> - nice overview of main CMake things and main CMake concepts in general</li><li><a href=https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/>&ldquo;It&rsquo;s time to do CMake Right&rdquo;</a> <a href=https://web.archive.org/web/20210415182304/https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/>(archive)</a> by Pablo Arias. A fantastic article about writing CMake for libraries meant to be used for other people and easy to include as a dependency in other projects.</li><li><a href="https://www.youtube.com/watch?v=eC9-iRN2b04">&ldquo;Using Modern CMake Patterns to Enforce a Good Modular Design&rdquo;</a> by Mathieu Ropert. A very nice talk about writing good CMake scripts.</li></ul></article></main><footer id=footer>© 2022 Elias Daler. All rights reserved.<p>subscribe via <a href=https://eliasdaler.github.io/feed.xml>RSS</a></p></footer></body></html>