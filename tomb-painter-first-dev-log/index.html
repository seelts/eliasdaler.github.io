<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://eliasdaler.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=alternate type=application/rss+xml href=https://eliasdaler.github.io/feed.xml title="Elias Daler's blog"><title>Tomb Painter. The first dev log (2017-2018)</title></head><body><header id=banner><h2><a href=https://eliasdaler.github.io>Elias Daler's blog</a></h2><nav><ul></ul></nav></header><main id=content><article><header id=post-header><h1>Tomb Painter. The first dev log (2017-2018)</h1><div>Publication date: <time>January 6, 2019</time></div><div></div></header><hr><p>Hello, everyone. Today I&rsquo;m ready to officially announce and talk about the game I&rsquo;m currently working on!</p><figure><img src=tomb-painter-logo.png></figure><p>It&rsquo;s called Tomb Painter and I&rsquo;ve been working on it since August of 2017.</p><figure><img src=characters.png></figure><p>In the game, a painter arrives on mysterious island, which has strange things going on with it. Blob-shaped monsters made of paint start to appear from an ancient tomb. The only way to stop this is to paint beautiful patterns which were washed away by a flood that happened some time ago.</p><p>The main mechanic is that you can draw on floors and paint stuff by hitting it with your brush. By painting on the floor, you solve different puzzles.</p><figure><img src=gameplay.gif></figure><div><h2>Table Of Contents</h2><nav id=TableOfContents><ul><li><a href=#start-of-development>Start of development</a></li><li><a href=#game--engine-separation>Game / engine separation</a></li><li><a href=#cmake--fetchcontent--third-party-dependencies>CMake / FetchContent / Third party dependencies</a></li><li><a href=#cutscene-system>Cutscene system</a></li><li><a href=#quest-and-saving-system>Quest and saving system</a></li><li><a href=#replay-system>Replay system</a></li><li><a href=#data--script-separation>Data / script separation</a></li><li><a href=#other>Other</a></li><li><a href=#whats-next>What&rsquo;s next?</a></li></ul></nav></div><h2 id=start-of-development>Start of development</h2><p>I&rsquo;ve started to work on this game, because developing <a href=https://eliasdaler.github.io/re-creation/>Re:creation</a> became too hard for me. It had gigantic scope and pretty detailed art, which took a long time to produce, so I&rsquo;ve decided to make something simpler as my first game.</p><p>It all started with this prototype art, which was highly inspired by <a href=http://minitgame.com/>Minit</a>:</p><figure><img src=tomb-painter-first-prototype.png></figure><p>I was pretty surprised that so much can be accomplished with only two colors, but I wanted a bit more detail, so I&rsquo;ve decided to use 4 colors, just like Game Boy did:</p><figure><img src=tomb-painter-early.png></figure><figure><img src=early-gameplay.gif></figure><p>The game&rsquo;s internal resolution is 160x144 pixels, same as Game Boy again. I&rsquo;ve decided not to follow all limitations of Game Boy, as it would be pretty hard to make a good looking game with them, but still, 4 colors and 160x144 is pretty limiting, while it can also look good. It also takes a lot less time to produce art.</p><p>I&rsquo;ve also experimented with adding a second palette (just like Super Game Boy on SNES did) and it looked pretty interesting:</p><figure><img src=early-gameplay2.gif></figure><p>You can also see first painting system which was improved later.</p><p>So now I have two palettes with 4 colors each. The game is rendered in shades of grey and I can easily map each shade to whatever color I want to get different palettes, including the original Game Boy one:</p><figure><img src=gameboy.png></figure><p>I also made some simple shaders for fade in and fade out:</p><figure><img src=fadein-fadeout.gif></figure><p>and for lighting simulation:</p><figure><img src=light.gif></figure><p>It&rsquo;s still 4 colors, but it looks pretty nice.</p><p>A lot of time was spent on making paint look and feel good. Note that the tiles of paint change depending on direction you&rsquo;re painting in, so it looks like a continuous trail, and you can also have multiples layer of paint. The paint also changes the color of what&rsquo;s below it and that was pretty interesting to implement too. I may write about all that shader magic in the future.</p><figure><img src=painting.gif></figure><p>As for more technical details: I&rsquo;ve used Re:creation&rsquo;s engine and started to modify it as I needed. I had working prototype of Tomb Painter in two weeks and it felt good to not start from scratch. All the abstractions and worries about design were worth it!</p><p>I&rsquo;ve improved the engine quite a lot and if I start to go over it all in detail, so I&rsquo;ll make a short summary here, and if you want to have it explained in depth, ask about stuff you want to be covered in comments!</p><h2 id=game--engine-separation>Game / engine separation</h2><p>Right now I&rsquo;m still working on better game / engine separation, but basically the engine is now a statically linked library. I&rsquo;ve decided to call the engine <strong>EDGE</strong> (Elias Daler&rsquo;s Game Engine). The &ldquo;game&rdquo; part is just several .cpp files and mostly just Lua code, because I prefer to code game logic in it. Once I feel that engine is decoupled enough and I have some time to make a simple game with it, I plan to open source the engine part!</p><h2 id=cmake--fetchcontent--third-party-dependencies>CMake / FetchContent / Third party dependencies</h2><p>I&rsquo;ve learned a lot about CMake (thanks to <a href=https://crascit.com/professional-cmake/>Professional CMake book</a>) and finally achieved a perfect setup for me. I&rsquo;ve managed to get all third party dependencies (9 of them) to be fetched at configure time. Then, I build all the dependencies and my game. It works perfectly - it&rsquo;s easy to start with a clean folder and just build everything!
It&rsquo;s also very easy to update to new versions of the libraries, here&rsquo;s the only thing I need to do:</p><figure><img src=changing-lib-versions.png></figure><h2 id=cutscene-system>Cutscene system</h2><p>I&rsquo;ve written an article about how I write cutscenes with coroutines <a href=https://eliasdaler.github.io/how-to-implement-action-sequences-and-cutscenes/>here</a>. It&rsquo;s pretty great! A lot of code was simplified and now I can easily write complex action sequences, multi-branch cutscenes and dialogue trees with it. So, with the code like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=font-weight:700>local</span> answer <span style=font-weight:700>=</span> girl:say(<span style=color:#b84>&#39;do_you_love_lua&#39;</span>,
</span></span><span style=display:flex><span>                          { <span style=color:#b84>&#39;YES&#39;</span>, <span style=color:#b84>&#39;NO&#39;</span> })
</span></span><span style=display:flex><span><span style=font-weight:700>if</span> answer <span style=font-weight:700>==</span> <span style=color:#b84>&#39;YES&#39;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>  girl:setMood(<span style=color:#b84>&#39;happy&#39;</span>)
</span></span><span style=display:flex><span>  girl:say(<span style=color:#b84>&#39;happy_response&#39;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>  girl:setMood(<span style=color:#b84>&#39;angry&#39;</span>)
</span></span><span style=display:flex><span>  girl:say(<span style=color:#b84>&#39;angry_response&#39;</span>)
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>I get this:</p><figure><img src=dialogue.gif></figure><h2 id=quest-and-saving-system>Quest and saving system</h2><p>It&rsquo;s now possible to have a main quest line in the game, but also side quests with multiple states which are easy to write, modify and read.</p><p>Previously, Re:creation had a very simple save system which saved your inventory, main quest progression, etc. But I&rsquo;ve decided that I needed something more complex for Tomb Painter, to store consequences of NPC interactions or side quest progression. The current system tracks game&rsquo;s state in real time and saves all important stuff in a Lua table once it happens (by catching events). Then, when you save, this table is just converted to JSON and saved to a file. Pretty awesome!</p><h2 id=replay-system>Replay system</h2><p>I&rsquo;ve also implemented a replay system which lets me record all input and then replay it in any speed I want. I can record minutes of gameplay and then run it very fast! I can also use it to quickly repeat some tasks (e.g. kill two enemies than go to room X) and then continue playing the game. Here&rsquo;s how all this looks in action:</p><figure><img src=replay.gif></figure><h2 id=data--script-separation>Data / script separation</h2><p>Previously, I&rsquo;ve stored all information about prefabs in Lua scripts. But then I&rsquo;ve decided that they&rsquo;d look better in JSON and it&rsquo;ll be much easier to write a GUI tool for modifying prefabs in the future. Here&rsquo;s an example of how prefab looks:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b84>&#34;slime&#34;</span> <span style=color:#a61717;background-color:#e3d2d2>:</span> {
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;ai&#34;</span> : {
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;type&#34;</span> : <span style=color:#b84>&#34;chaser&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;viewRadius&#34;</span> : <span style=color:#099>60</span>,
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;viewAngle&#34;</span> : <span style=color:#099>90</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;animation&#34;</span> : { },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;collision&#34;</span> : { <span style=color:navy>&#34;boundingBox&#34;</span> : [ <span style=color:#099>6</span>, <span style=color:#099>4</span> ] },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;damage&#34;</span> : {
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;amount&#34;</span> : <span style=color:#099>1</span>,
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;type&#34;</span> : <span style=color:#b84>&#34;physical&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;graphics&#34;</span> : {
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;spriteOrigin&#34;</span> : [ <span style=color:#099>8</span>, <span style=color:#099>10</span> ],
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;overlays&#34;</span> : {
</span></span><span style=display:flex><span>            <span style=color:navy>&#34;paint&#34;</span> : <span style=color:#b84>&#34;slime_overlay&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;health&#34;</span> : { <span style=color:navy>&#34;maxHealth&#34;</span> : <span style=color:#099>2</span> },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;movement&#34;</span> : {
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;moveSpeed&#34;</span> : [ <span style=color:#099>15.0</span>, <span style=color:#099>15.0</span> ],
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;mass&#34;</span> : <span style=color:#099>0.5</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;sound&#34;</span> : {
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;sounds&#34;</span> : {
</span></span><span style=display:flex><span>            <span style=color:navy>&#34;hit&#34;</span> : { <span style=color:navy>&#34;file&#34;</span> : <span style=color:#b84>&#34;enemy_hit&#34;</span> },
</span></span><span style=display:flex><span>            <span style=color:navy>&#34;die&#34;</span> : { <span style=color:navy>&#34;file&#34;</span> : <span style=color:#b84>&#34;enemy_die&#34;</span> }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:navy>&#34;stateMachine&#34;</span> : {
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;main&#34;</span> : {
</span></span><span style=display:flex><span>            <span style=color:navy>&#34;initialState&#34;</span> : <span style=color:#b84>&#34;IdleState&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:navy>&#34;transitionTable&#34;</span> : <span style=color:#b84>&#34;hero&#34;</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:navy>&#34;ai&#34;</span> : {
</span></span><span style=display:flex><span>            <span style=color:navy>&#34;initialState&#34;</span> : <span style=color:#b84>&#34;AIPatrolState&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:navy>&#34;transitionTable&#34;</span> : <span style=color:#b84>&#34;ai_slime&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, it&rsquo;s easy to read. Transition tables are still written in Lua, because they usually have conditions inside of them and they look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>{
</span></span><span style=display:flex><span>    IdleState <span style=font-weight:700>=</span> {
</span></span><span style=display:flex><span>        update <span style=font-weight:700>=</span> <span style=font-weight:700>function</span>(entity)
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> <span style=font-weight:700>not</span> entity:getVelocity():isZero() <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> <span style=color:#b84>&#34;MoveState&#34;</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    MoveState <span style=font-weight:700>=</span> {
</span></span><span style=display:flex><span>        update <span style=font-weight:700>=</span> <span style=font-weight:700>function</span>(entity)
</span></span><span style=display:flex><span>            <span style=font-weight:700>if</span> entity:getVelocity():isZero() <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>return</span> <span style=color:#b84>&#34;IdleState&#34;</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    DyingState <span style=font-weight:700>=</span> {
</span></span><span style=display:flex><span>        [EventType.AnimationFinished] <span style=font-weight:700>=</span> {
</span></span><span style=display:flex><span>            callback <span style=font-weight:700>=</span> <span style=font-weight:700>function</span>(entity, event)
</span></span><span style=display:flex><span>                <span style=font-weight:700>if</span> event.data.animationName <span style=font-weight:700>==</span> <span style=color:#b84>&#34;dying&#34;</span> <span style=font-weight:700>then</span>
</span></span><span style=display:flex><span>                    <span style=font-weight:700>return</span> <span style=color:#b84>&#34;DiedState&#34;</span>
</span></span><span style=display:flex><span>                <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Update fuction can either call <code>setState</code> explicitly, or just return a name of the state to transition into. Another way to transition is by catching the event. So, if entity is in <code>DyingState</code> and it catches <code>AnimationFinished</code> event, the callback is called where it can then transition into another state.</p><h2 id=other>Other</h2><p>All GUI widgets are now entities, which is very useful as they can be manipulated as normal game objects and I don&rsquo;t have any repeating rendering/movement code.</p><p>Also, I&rsquo;ve worked a lot on resource and entity prefab management. Now, entity prefabs are ref counted and if entity prefab is unused on another level, it&rsquo;s unloaded with all resources which it was using (unless other prefabs use it too). The system is very complex to explain in a few paragraphs and I might write an article about it later.</p><p>And there was a lot of refactoring, of course. All the code is now in its best condition ever.</p><h2 id=whats-next>What&rsquo;s next?</h2><figure><img src=shadows.png></figure><p>Right now, my next goal is making game look even prettier shadows (see the screenshot above), animated tiles, a new level, the first boss and the first awesome mini-game. Overall, the progress looks very good and I&rsquo;m very happy with my engine and I can&rsquo;t wait to start working on the game again. I&rsquo;ll also have a lot more time to work on the game (find out why in the next post!), so it&rsquo;s going to be awesome.</p><p>See you soon! Thanks for reading.</p></article></main><footer id=footer>© 2022 Elias Daler. All rights reserved.<p>subscribe via <a href=https://eliasdaler.github.io/feed.xml>RSS</a></p></footer></body></html>